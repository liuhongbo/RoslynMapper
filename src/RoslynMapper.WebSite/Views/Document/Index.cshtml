@{
    ViewBag.Title = "Document";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div>
    <h1 class="page-header">Document</h1>
    <p class="muted">document for v0.1.7-alpha</p>

    <div class="row">
        <div class="col-md-9">
            <div id="name-convention">
                <h3>Name convention</h3>
                <p>Roslyn Mapper uses some name name conventions for the API. Understand the name conventions will help you understand the API.</p>
                <strong>
                    T1 represents the source type, T2 represents the destination type.
                </strong>
                <p>For example,</p>
                <pre class="prettyprint">
IMapping&lt;T1, T2&gt; Resolve(Expression&lt;func&lt;T2, object&gt;&gt; t2, Action&lt;T1, T2&gt; resolver); </pre>
                <p>The first parameter is a lambda expression to specify a destination type member. The second parameter is a action used as the resolver. The resolver takes source type object and destination type object as the action's parameters.</p>
                <strong>A mapper is a component that can map a source type object to the destination type object.</strong>
                <p>For example,</p>
                <pre class="prettyprint">
IMapping&lt;T1, T2&gt; SetMapper&lt;T1, T2&gt;();
</pre>
                <strong>Mapping is the process of converting the source type object to the destionation type object. It is used in the fluent interface name.</strong>
                <p>For example,</p>
                <pre class="prettyprint">
public interface IMapping&lt;T1, T2&gt;
public interface IMemberMapping&lt;T1, T2&gt;
</pre>
            </div>

            <div id="setup-mappers">
                <h3>Setup Mappers</h3>
                <p>Set up the mapper and build it in your program startup.</p>
                <pre class="prettyprint">
var mapper = RoslynMapper.MapEngine.DefaultInstance;
mapper.SetMapper&lt;A, B&gt;();
...
mapper.Build();
</pre>
                <p>The setup will compile the mappers at the end which will take about 2 to 3 seconds for the first time compiling.</p>
                <p>The default map engine instance is used for most senarios. The map engine host all the type maps and mappers. If you want to use multiple map engines in your application, </p>
                <pre class="prettyprint">
var mapper = new RoslynMapper.MapEngine();
</pre>
                <p>This will create a new map engine shares nothing with the default map engine.</p>
                <p>For the same source type to destination type, if you want to sepcify two different map rules. You can create two mappers with different names. For example, Map type A to type B, in your application some time you want to igore member value1, sometime you dont want to igore it, so you can create two different mappers for type A to B map.</p>
                <pre class="prettyprint">
mapper.SetMapper&lt;A,B&gt;(&quot;mapper1&quot;).Ignore(t2=&gt;t2.Value1);
mapper.SetMapper&lt;A,B&gt;(&quot;mapper2&quot;);
</pre>
                <p>Then you can use the name to specify which mapper you want to use for the current mapping.</p>
                <pre class="prettyprint">
mapper.Map&lt;A,B&gt;(&quot;mapper1&quot;,a,b);
</pre>
                <p>Setup for dynamic map is not needed.</p>
            </div>

            <div id="member-bind">
                <h3>Member bind</h3>
                <p>By default, RoslynMapper use the member's name to match the members. For example,</p>                
<pre class="prettyprint">
public class A
{
    public string Name { get; set; }
}
public class B
{
    public string Name;
}</pre>                
                <p>The setup for the mapper does not need to specify how the members bind.</p>
                <div>
<pre class="prettyprint">
mapper.SetMapper&lt;A,B&gt;();
</pre>
                </div>
                <p>However if you have two members that have different name but you want to bind them, for example,</p>
<pre class="prettyprint">
public class A
{
    public string Name { get; set; }
}
public class B
{
    public string OtherName;
}</pre>
                <p>You can use the Bind method to sepecify the custom member bind.</p>
<pre class="prettyprint">
mapper.SetMapper&lt;A, B&gt;().Bind(t1=&gt;t1.Name, t2=&gt;t2.OtherName);
</pre>                
            </div>

            <div id="type-resolver">
                <h3>Type resolver</h3>
                <p>Use type resolver to fully specify how to map source type object to destination object</p>
                <p>For example,</p>
                <pre class="prettyprint">
public class A
{
    public int Value { get; set; }            
}
        
public class B
{
    public int OtherValue { get; set; }
    public string OtherString { get; set; }
}
mapper.SetMapper&lt;A, B&gt;().Resolve((s, d) =&gt; { d.OtherValue = s.Value * 4; d.OtherString = string.Format(&quot;Value is: {0}&quot;, s.Value); });
</pre>
            </div>

            <div id="member-resolver">
                <h3>Member resolver</h3>
                <p>Use the member resolver to specify how to map the specific member of the destination type.</p>
                <p>For example,</p>
                <pre class="prettyprint">
public class A
{
    public int Value { get; set; }            
}
        
public class B
{
    public int OtherValue { get; set; }
}

mapper.SetMapper&lt;A, B&gt;().Resolve(t2 =&gt; t2.OtherValue, (s, d) =&gt; d.OtherValue = s.Value * 5);
</pre>
            </div>

            <div id="nested-member">
                <h3>Nested member</h3>
                <p>Nested members mapping is supported by default. For example,</p>
                <div>
<pre class="prettyprint">
public class A
{
    public class Int1
    {
        public int i = 10;
    }
    public Int1 i1 = new Int1();
}
public class B
{
    public class Int1
    {
        public int i;
    }
    public Int1 i1 { get; set; }
}</pre>
                </div>
                <p>Just use the default mapper setup,</p>
<pre class="prettyprint">
mapper.SetMapper&lt;A, B&gt;();
</pre>
                <p>The mapper is able to map the nested members use the default name matching rule.</p>
            </div>
        </div>       
        <div class="col-md-3">
            <ul>
                <li><a href="#name-convention">Name convention</a></li>
                <li><a href="#name-convention">Setup Mappers</a></li>
                <li><a href="#ignore-member">Ignore Member</a></li>
                <li><a href="#name-convention">Member bind</a></li>
                <li><a href="#name-convention">Type resolver</a></li>
                <li><a href="#name-convention">Member resolver</a></li>
                <li><a href="#nested-member">Nested Member</a></li>
                <li><a href="#Conditional-mapping">Conditional Mapping</a></li>
                <li><a href="#dynamic-mapping">Dynamic Mapping</a></li>
            </ul>
        </div>
    </div>
</div>

