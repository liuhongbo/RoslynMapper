
@{
    ViewBag.Title = "How it works";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div>
    <h1 class="page-header">How it works</h1>
    <p class="lead">Using the Microsoft Compile Platform (Rosyln) to compile the mapping logic into a in-memory danymic link library, RoslynMapper is able to achieve a hand write mapping performance.</p>
    <p class="muted">Speed does matter in our applications.</p>

    <strong>RoslynMapper does one thing and only does one thing: Map object from one type to another type.  </strong>

    <h3>Define the source type and destination type.</h3>
    <p>Simple source type and destination type defination.</p>

<pre class="prettyprint">
public class A
{
    public string Name { get; set; }
}
public class B
{
    public string Name;
}
</pre>

    <h3>Set up the mapper in your program startup.</h3>
    <p>RoslynMapper will save the configuration for each type map which will be used to create the mapper.</p>

<pre class="prettyprint">
var mapper = RoslynMapper.MapEngine.DefaultInstance;
mapper.SetMapper&lt;a, b&gt;();
</pre>

    <h3>Build the mapper</h3>
    <p>RoslynMapper will generate the source code for the mapper first, the source code looks like this:</p>

<pre class="prettyprint">
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using RoslynMapper.Map;
namespace RoslynMapper.Mapper
{
    class RoslynMapper_Samples_HelloWorld_A__Map__RoslynMapper_Samples_HelloWorld_B__:MapperBase&lt;roslynmapper.samples.helloworld.a,roslynmapper.samples.helloworld.b&gt;,IMapper&lt;roslynmapper.samples.hello world.a,roslynmapper.samples.helloworld.b&gt;
    {
        private IMapEngine _engine;
        private ITypeMap _typeMap;
        public RoslynMapper_Samples_HelloWorld_A__Map__RoslynMapper_Samples_HelloWorld_B__(IMapEngine engine, ITypeMap typeMap)
        {
            _engine = engine;
            _typeMap = typeMap;
        }
        public RoslynMapper.Samples.HelloWorld.B Map(RoslynMapper.Samples.HelloWorld.A t1)
        {
            return Map(t1, new RoslynMapper.Samples.HelloWorld.B());
        }
        public RoslynMapper.Samples.HelloWorld.B Map(RoslynMapper.Samples.HelloWorld.A t1, RoslynMapper.Samples.HelloWorld.B t2)
        {
            t2.Name=t1.Name;
            return t2;
        }
        public override int GetHashCode()
        {
            return 694497719;
        }
        public override IMapEngine MapEngine
        {
            get
            {
                return  _engine;
            }
        }
        public override ITypeMap&lt;roslynmapper.samples.helloworld.a,roslynmapper.samples.helloworld.b&gt; TypeMap
        {
            get
            {
                return (ITypeMap&lt;roslynmapper.samples.helloworld.a,roslynmapper.samples.helloworld.b&gt;)_typeMap;
            }
        }
    }
}
</pre>

    <h3>Use Microsoft Compile Platform to compile the source code to a in-memory DLL</h3>
    <p>The code that does the compiling looks like this:</p>

<pre class="prettyprint">
protected Assembly BuildAssembly(string code, IEnumerable&lt;itypemap&gt; typeMaps, string assemblyName)
{
    var tree = SyntaxFactory.ParseSyntaxTree(code);            
    var compilation = CSharpCompilation.Create(
        assemblyName,
        options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary),
        syntaxTrees: new[] { tree },
        references: GetMetadataFileReferences(typeMaps));
    Assembly compiledAssembly = null;
    using (var stream = new MemoryStream())
    {
        var compileResult = compilation.Emit(stream);
        if (compileResult.Success)
        {
            compiledAssembly = Assembly.Load(stream.GetBuffer());
        }
    }            
    return compiledAssembly;
}
</pre>

    <h3>Create the mapper instance that support the IMapper interface</h3>
    <p>RoslynMapper will create all the mappers right after the compiling using reflection. </p>

<pre class="prettyprint">
Type mapType = assembly.GetType(string.Format(&quot;{0}.{1}&quot;, GetNamespace(typeMaps), typeMap.MapperName));
if (mapType != null)
{
    IMapper mapper = (IMapper)Activator.CreateInstance(mapType, engine, typeMap);
    if (mapper != null)
    {
        mappers.Add(new KeyValuePair&lt;mapkey, imapper&gt;(typeMap.Key, mapper));
    }
}   
</pre>
    
    <h3>Use the IMapper interface to map the object from one type to another.</h3>
    <p>RoslynMapper will return the corresponsive mapper for the specific type map which support the IMapper interfae.</p>

<pre class="prettyprint">
A a = new A() { Name = &quot;Hello World&quot; };
var b = mapper.Map&lt;a, b&gt;(a);
</pre>

    <p>For more inforamtion, read the <a href="@Url.Action("Index","Document")">document</a>.</p>
</div>
